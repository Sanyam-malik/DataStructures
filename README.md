# Data Structures Practice Project

Welcome to the Data Structures Practice Project! This project is designed to help you improve your understanding and implementation skills of various data structures commonly used in programming.

## Project Overview

In this project, you'll find a collection of data structure implementations and related exercises. Each data structure is organized into its own directory, containing the implementation, usage examples, and practice exercises. The goal is to learn how these data structures work and how to apply them effectively in different scenarios.

## Table of Contents

- [Data Structures](#data-structures)
  - [Linked List](#linked-list)
  - [Stack](#stack)
  - [Queue](#queue)
  - [Binary Tree](#binary-tree)
  - [Hash Table](#hash-table)
  - [Graph](#graph)
- [How to Use](#how-to-use)
- [Contributing](#contributing)
- [License](#license)

## Data Structures

### Linked List

Learn about linked lists and their variations such as singly linked lists, doubly linked lists, and circular linked lists. Implement common operations like insertion, deletion, and traversal.

### Stack

Understand stacks and their LIFO (Last-In-First-Out) behavior. Implement push, pop, and peek operations. Explore use cases like expression evaluation and backtracking algorithms.

### Queue

Explore queues with their FIFO (First-In-First-Out) behavior. Implement enqueue, dequeue, and front operations. Learn about priority queues and applications in breadth-first search.

### Binary Tree

Dive into binary trees and their traversal methods like in-order, pre-order, and post-order. Implement binary search trees and practice common operations like insertion, deletion, and searching.

### Hash Table

Study hash tables and their collision resolution techniques. Implement basic hash functions, handle collisions with chaining or open addressing, and understand hash table performance.

### Graph

Discover graph representations (adjacency matrix, adjacency list) and traversal algorithms (depth-first search, breadth-first search). Implement these algorithms and solve graph-based problems.

# Algorithms to Remember While Studying Data Structures and Algorithms

When studying data structures (DS) and algorithms (DS&A), it's essential to focus on fundamental algorithms that provide a strong foundation for problem-solving. Here's a list of key algorithms to remember:

## Sorting Algorithms
- [x] Bubble Sort
- [x] Selection Sort
- [x] Insertion Sort
- [x] Quick Sort
- [x] Merge Sort
- [-] Heap Sort
- [ ] Radix Sort

## Searching Algorithms
- [x] Linear Search
- [x] Binary Search

## Graph Algorithms
- [x] Depth-First Search (DFS)
- [x] Breadth-First Search (BFS)
- [x] Dijkstra's Algorithm (shortest path in weighted graphs)
- [x] Bellman-Ford Algorithm (shortest path with negative weights)
- [ ] Floyd-Warshall Algorithm (all-pairs shortest paths)
- [x] Topological Sort (for directed acyclic graphs)

## Dynamic Programming
- [ ] Fibonacci Series (conceptual understanding)
- [ ] Memoization and Tabulation techniques
- [ ] Longest Common Subsequence (LCS)
- [ ] Knapsack Problem
- [ ] Matrix Chain Multiplication
- [ ] Shortest Path Problems (using dynamic programming)

## Data Structures
- [x] Arrays and Strings (basic building blocks)
- [x] Linked Lists (singly and doubly)
- [x] Stacks and Queues
- [ ] Trees (Binary Trees, Binary Search Trees, AVL Trees, etc.)
- [x] Graphs (adjacency matrix and adjacency list representations)
- [ ] Heaps (Binary Heaps and Priority Queues)
- [x] Hash Tables (Hash Maps)
- [ ] Disjoint Set Union (Union-Find)
- [x] Trie (Prefix Tree)

## Advanced Algorithms (Optional)
- [ ] Kruskal's Algorithm (minimum spanning tree)
- [x] Prim's Algorithm (minimum spanning tree)
- [ ] A* Search Algorithm (heuristic-based pathfinding)
- [ ] Suffix Arrays and Suffix Trees (advanced string matching)
- [ ] Bloom Filters (approximate set membership)

## Algorithmic Paradigms
- [ ] Greedy Algorithms (e.g., Huffman Coding, Prim's Algorithm)
- [x] Divide and Conquer (e.g., Merge Sort, Quick Sort)
- [ ] Backtracking (e.g., N-Queens Problem)
- [ ] Dynamic Programming (e.g., solving optimization problems)

## Complexity Analysis
- [ ] Understanding Big O notation and time/space complexity analysis for various algorithms.

## Common Coding Patterns
- [x] Sliding Window
- [x] Two-Pointer
- [x] Depth-First Search (DFS) and Breadth-First Search (BFS) templates
- [x] Fast and Slow Pointers (for cycle detection)

## Online Resources
- LeetCode, HackerRank, and other coding challenge websites for practical application.

Remember that understanding the principles behind these algorithms, their time and space complexity, and when to use them is more important than memorizing code. You can always refer to code examples and implementations when needed, but a solid understanding of the underlying concepts will help you excel in DS&A interviews and real-world problem-solving.


## How to Use

1. Clone the repository:

   ```sh
   git clone http://lordmaximus.duckdns.org/data-structures/practice
